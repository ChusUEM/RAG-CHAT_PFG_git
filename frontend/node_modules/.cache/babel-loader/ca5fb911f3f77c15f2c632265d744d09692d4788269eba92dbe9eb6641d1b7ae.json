{"ast":null,"code":"var _jsxFileName = \"/Users/chus/Desktop/PFG/RAG-CHAT_PFG_git/frontend/src/store/provider.tsx\";\nimport { Provider, useDispatch, useSelector } from 'react-redux';\nimport { fetchEventSource } from '@microsoft/fetch-event-source';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass RetriableError extends Error {}\nclass FatalError extends Error {}\nexport let AppStatus = /*#__PURE__*/function (AppStatus) {\n  AppStatus[\"Idle\"] = \"idle\";\n  AppStatus[\"StreamingMessage\"] = \"loading\";\n  AppStatus[\"Done\"] = \"done\";\n  AppStatus[\"Error\"] = \"error\";\n  return AppStatus;\n}({});\nvar STREAMING_EVENTS = /*#__PURE__*/function (STREAMING_EVENTS) {\n  STREAMING_EVENTS[\"SESSION_ID\"] = \"[SESSION_ID]\";\n  STREAMING_EVENTS[\"SOURCE\"] = \"[SOURCE]\";\n  STREAMING_EVENTS[\"DONE\"] = \"[DONE]\";\n  return STREAMING_EVENTS;\n}(STREAMING_EVENTS || {});\nconst GLOBAL_STATE = {\n  status: AppStatus.Idle,\n  conversation: [],\n  sessionId: null,\n  sources: []\n};\nconst API_HOST = process.env.REACT_APP_API_HOST || 'http://localhost:3001/api';\nlet abortController = null;\nconst globalSlice = createSlice({\n  name: 'global',\n  initialState: GLOBAL_STATE,\n  reducers: {\n    addSource: (state, action) => {\n      const source = action.payload.source;\n      const rootSource = state.sources.find(s => s.name === source.name);\n      if (rootSource) {\n        if (!rootSource.summary.find(summary => summary === source.summary)) {\n          rootSource.summary = [...rootSource.summary, source.summary];\n        }\n      } else {\n        state.sources.push({\n          ...source,\n          summary: [source.summary]\n        });\n      }\n    },\n    setStatus: (state, action) => {\n      state.status = action.payload.status;\n    },\n    setSessionId: (state, action) => {\n      state.sessionId = action.payload.sessionId;\n    },\n    addMessage: (state, action) => {\n      state.conversation.push(action.payload.conversation);\n    },\n    updateMessage: (state, action) => {\n      const messageIndex = state.conversation.findIndex(c => c.id === action.payload.id);\n      if (messageIndex !== -1) {\n        state.conversation[messageIndex] = {\n          ...state.conversation[messageIndex],\n          ...action.payload\n        };\n      }\n    },\n    setMessageSource: (state, action) => {\n      const message = state.conversation.find(c => c.id === action.payload.id);\n      if (message) {\n        message.sources = action.payload.sources.map(sourceName => state.sources.find(stateSource => stateSource.name === sourceName)).filter(source => !!source);\n      }\n    },\n    removeMessage: (state, action) => {\n      const messageIndex = state.conversation.findIndex(c => c.id === action.payload.id);\n      if (messageIndex !== -1) {\n        state.conversation.splice(messageIndex, 1);\n      }\n    },\n    sourceToggle: (state, action) => {\n      const source = state.sources.find(s => s.name === action.payload.name);\n      if (source) {\n        var _action$payload$expan;\n        source.expanded = (_action$payload$expan = action.payload.expanded) !== null && _action$payload$expan !== void 0 ? _action$payload$expan : !source.expanded;\n      }\n    },\n    reset: state => {\n      state.status = AppStatus.Idle;\n      state.sessionId = null;\n      state.conversation = [];\n      state.sources = [];\n    }\n  }\n});\nconst store = configureStore({\n  reducer: globalSlice.reducer\n});\nexport const useAppDispatch = useDispatch;\nexport const useAppSelector = useSelector;\nexport const actions = globalSlice.actions;\nexport const thunkActions = {\n  search: query => {\n    return async function fetchSearch(dispatch, getState) {\n      if (getState().status === AppStatus.StreamingMessage) {\n        dispatch(thunkActions.abortRequest());\n      }\n      dispatch(actions.reset());\n      dispatch(thunkActions.chat(query));\n    };\n  },\n  askQuestion: question => {\n    return async function (dispatch, getState) {\n      const state = getState();\n      dispatch(actions.addMessage({\n        conversation: {\n          isHuman: true,\n          content: question,\n          id: state.conversation.length + 1\n        }\n      }));\n      dispatch(thunkActions.chat(question));\n    };\n  },\n  chat: question => {\n    return async function fetchSearch(dispatch, getState) {\n      abortController = new AbortController();\n      const conversationId = getState().conversation.length + 1;\n      dispatch(actions.addMessage({\n        conversation: {\n          isHuman: false,\n          content: '',\n          id: conversationId\n        }\n      }));\n      dispatch(actions.setStatus({\n        status: AppStatus.StreamingMessage\n      }));\n      let countRetiresError = 0;\n      let message = '';\n      const sessionId = getState().sessionId;\n      const sourcesMap = new Map();\n      await fetchEventSource(`${API_HOST}/chat${sessionId ? `?session_id=${sessionId}` : ''}`, {\n        method: 'POST',\n        openWhenHidden: true,\n        body: JSON.stringify({\n          question\n        }),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: abortController.signal,\n        async onmessage(event) {\n          if (event.event === 'FatalError') {\n            throw new FatalError(event.data);\n          }\n          if (event.data.startsWith(STREAMING_EVENTS.SESSION_ID)) {\n            const sessionId = event.data.split(' ')[1].trim();\n            dispatch(actions.setSessionId({\n              sessionId\n            }));\n          } else if (event.data.startsWith(STREAMING_EVENTS.SOURCE)) {\n            const source = event.data.replace(`${STREAMING_EVENTS.SOURCE} `, '');\n            try {\n              if (source) {\n                const parsedSource = JSON.parse(source.replaceAll('\\n', ''));\n                if (parsedSource.page_content && parsedSource.name) {\n                  dispatch(actions.addSource({\n                    source: {\n                      name: parsedSource.name,\n                      url: parsedSource.url,\n                      summary: parsedSource.page_content,\n                      icon: parsedSource.category,\n                      updated_at: parsedSource.updated_at\n                    }\n                  }));\n                }\n              }\n            } catch (e) {\n              console.log('error', source, event.data);\n              console.error(e);\n            }\n          } else if (event.data === STREAMING_EVENTS.DONE) {\n            const sources = parseSources(message);\n            dispatch(actions.setMessageSource({\n              id: conversationId,\n              sources\n            }));\n            dispatch(actions.setStatus({\n              status: AppStatus.Done\n            }));\n          } else {\n            message += event.data;\n            dispatch(actions.updateMessage({\n              id: conversationId,\n              content: message.replace(/SOURCES:(.+)*/, '')\n            }));\n          }\n        },\n        async onopen(response) {\n          if (response.ok) {\n            return;\n          } else if (response.status >= 400 && response.status < 500 && response.status !== 429) {\n            throw new FatalError();\n          } else {\n            throw new RetriableError();\n          }\n        },\n        onerror(err) {\n          if (err instanceof FatalError || countRetiresError > 3) {\n            dispatch(actions.setStatus({\n              status: AppStatus.Error\n            }));\n            throw err;\n          } else {\n            countRetiresError++;\n            console.error(err);\n          }\n        }\n      });\n    };\n  },\n  abortRequest: () => {\n    return function (dispatch, getState) {\n      var _abortController;\n      const messages = getState().conversation;\n      const lastMessage = messages[getState().conversation.length - 1];\n      (_abortController = abortController) === null || _abortController === void 0 ? void 0 : _abortController.abort();\n      abortController = null;\n      if (!lastMessage.content) {\n        dispatch(actions.removeMessage({\n          id: lastMessage.id\n        }));\n      }\n      dispatch(actions.setStatus({\n        status: messages.length ? AppStatus.Done : AppStatus.Idle\n      }));\n    };\n  }\n};\nconst parseSources = message => {\n  message = message.replaceAll(\"\\\"\", \"\");\n  const match = message.match(/SOURCES:(.+)*/);\n  if (match && match[1]) {\n    return match[1].split(',').map(element => {\n      return element.trim();\n    });\n  }\n  return [];\n};\nexport const GlobalStateProvider = _ref => {\n  let {\n    children\n  } = _ref;\n  return /*#__PURE__*/_jsxDEV(Provider, {\n    store: store,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 314,\n    columnNumber: 10\n  }, this);\n};\n_c = GlobalStateProvider;\nvar _c;\n$RefreshReg$(_c, \"GlobalStateProvider\");","map":{"version":3,"names":["Provider","useDispatch","useSelector","fetchEventSource","configureStore","createSlice","jsxDEV","_jsxDEV","RetriableError","Error","FatalError","AppStatus","STREAMING_EVENTS","GLOBAL_STATE","status","Idle","conversation","sessionId","sources","API_HOST","process","env","REACT_APP_API_HOST","abortController","globalSlice","name","initialState","reducers","addSource","state","action","source","payload","rootSource","find","s","summary","push","setStatus","setSessionId","addMessage","updateMessage","messageIndex","findIndex","c","id","setMessageSource","message","map","sourceName","stateSource","filter","removeMessage","splice","sourceToggle","_action$payload$expan","expanded","reset","store","reducer","useAppDispatch","useAppSelector","actions","thunkActions","search","query","fetchSearch","dispatch","getState","StreamingMessage","abortRequest","chat","askQuestion","question","isHuman","content","length","AbortController","conversationId","countRetiresError","sourcesMap","Map","method","openWhenHidden","body","JSON","stringify","headers","signal","onmessage","event","data","startsWith","SESSION_ID","split","trim","SOURCE","replace","parsedSource","parse","replaceAll","page_content","url","icon","category","updated_at","e","console","log","error","DONE","parseSources","Done","onopen","response","ok","onerror","err","_abortController","messages","lastMessage","abort","match","element","GlobalStateProvider","_ref","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/chus/Desktop/PFG/RAG-CHAT_PFG_git/frontend/src/store/provider.tsx"],"sourcesContent":["import type { TypedUseSelectorHook } from 'react-redux'\nimport { Provider, useDispatch, useSelector } from 'react-redux'\nimport { fetchEventSource } from '@microsoft/fetch-event-source'\nimport { configureStore, createSlice } from '@reduxjs/toolkit'\nimport { SourceType, ChatMessageType } from 'types'\n\ntype GlobalStateType = {\n  status: AppStatus\n  conversation: ChatMessageType[]\n  sources: SourceType[]\n  sessionId: string | null\n}\n\nclass RetriableError extends Error {}\nclass FatalError extends Error {}\nexport enum AppStatus {\n  Idle = 'idle',\n  StreamingMessage = 'loading',\n  Done = 'done',\n  Error = 'error',\n}\nenum STREAMING_EVENTS {\n  SESSION_ID = '[SESSION_ID]',\n  SOURCE = '[SOURCE]',\n  DONE = '[DONE]',\n}\n\nconst GLOBAL_STATE: GlobalStateType = {\n  status: AppStatus.Idle,\n  conversation: [],\n  sessionId: null,\n  sources: [],\n}\nconst API_HOST = process.env.REACT_APP_API_HOST || 'http://localhost:3001/api'\n\nlet abortController: AbortController | null = null\nconst globalSlice = createSlice({\n  name: 'global',\n  initialState: GLOBAL_STATE as GlobalStateType,\n  reducers: {\n    addSource: (state, action) => {\n      const source = action.payload.source\n      const rootSource = state.sources.find((s) => s.name === source.name)\n\n      if (rootSource) {\n        if (!rootSource.summary.find((summary) => summary === source.summary)) {\n          rootSource.summary = [...rootSource.summary, source.summary]\n        }\n      } else {\n        state.sources.push({ ...source, summary: [source.summary] })\n      }\n    },\n    setStatus: (state, action) => {\n      state.status = action.payload.status\n    },\n    setSessionId: (state, action) => {\n      state.sessionId = action.payload.sessionId\n    },\n    addMessage: (state, action) => {\n      state.conversation.push(action.payload.conversation)\n    },\n    updateMessage: (state, action) => {\n      const messageIndex = state.conversation.findIndex(\n        (c) => c.id === action.payload.id\n      )\n\n      if (messageIndex !== -1) {\n        state.conversation[messageIndex] = {\n          ...state.conversation[messageIndex],\n          ...action.payload,\n        }\n      }\n    },\n    setMessageSource: (state, action) => {\n      const message = state.conversation.find((c) => c.id === action.payload.id)\n\n      if (message) {\n        message.sources = action.payload.sources\n          .map((sourceName) =>\n            state.sources.find((stateSource) => stateSource.name === sourceName)\n          )\n          .filter((source) => !!source)\n      }\n    },\n    removeMessage: (state, action) => {\n      const messageIndex = state.conversation.findIndex(\n        (c) => c.id === action.payload.id\n      )\n\n      if (messageIndex !== -1) {\n        state.conversation.splice(messageIndex, 1)\n      }\n    },\n    sourceToggle: (state, action) => {\n      const source = state.sources.find((s) => s.name === action.payload.name)\n\n      if (source) {\n        source.expanded = action.payload.expanded ?? !source.expanded\n      }\n    },\n    reset: (state) => {\n      state.status = AppStatus.Idle\n      state.sessionId = null\n      state.conversation = []\n      state.sources = []\n    },\n  },\n})\n\nconst store = configureStore({\n  reducer: globalSlice.reducer,\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\nexport const useAppDispatch: () => AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\nexport const actions = globalSlice.actions\n\nexport const thunkActions = {\n  search: (query: string) => {\n    return async function fetchSearch(dispatch, getState) {\n      if (getState().status === AppStatus.StreamingMessage) {\n        dispatch(thunkActions.abortRequest())\n      }\n\n      dispatch(actions.reset())\n      dispatch(thunkActions.chat(query))\n    }\n  },\n  askQuestion: (question: string) => {\n    return async function (dispatch, getState) {\n      const state = getState()\n\n      dispatch(\n        actions.addMessage({\n          conversation: {\n            isHuman: true,\n            content: question,\n            id: state.conversation.length + 1,\n          },\n        })\n      )\n      dispatch(thunkActions.chat(question))\n    }\n  },\n  chat: (question: string) => {\n    return async function fetchSearch(dispatch, getState) {\n      abortController = new AbortController()\n      const conversationId = getState().conversation.length + 1\n\n      dispatch(\n        actions.addMessage({\n          conversation: {\n            isHuman: false,\n            content: '',\n            id: conversationId,\n          },\n        })\n      )\n      dispatch(actions.setStatus({ status: AppStatus.StreamingMessage }))\n\n      let countRetiresError = 0\n      let message = ''\n      const sessionId = getState().sessionId\n      const sourcesMap: Map<\n        string,\n        { name: string; url?: string; summary: string[] }\n      > = new Map()\n\n      await fetchEventSource(\n        `${API_HOST}/chat${sessionId ? `?session_id=${sessionId}` : ''}`,\n        {\n          method: 'POST',\n          openWhenHidden: true,\n          body: JSON.stringify({\n            question,\n          }),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          signal: abortController.signal,\n          async onmessage(event) {\n            if (event.event === 'FatalError') {\n              throw new FatalError(event.data)\n            }\n\n            if (event.data.startsWith(STREAMING_EVENTS.SESSION_ID)) {\n              const sessionId = event.data.split(' ')[1].trim()\n              dispatch(actions.setSessionId({ sessionId }))\n            } else if (event.data.startsWith(STREAMING_EVENTS.SOURCE)) {\n              const source = event.data.replace(\n                `${STREAMING_EVENTS.SOURCE} `,\n                ''\n              )\n\n              try {\n                if (source) {\n                  const parsedSource: {\n                    name: string\n                    page_content: string\n                    url?: string\n                    category?: string\n                    updated_at?: string | null\n                  } = JSON.parse(source.replaceAll('\\n', ''))\n\n                  if (parsedSource.page_content && parsedSource.name) {\n                    dispatch(\n                      actions.addSource({\n                        source: {\n                          name: parsedSource.name,\n                          url: parsedSource.url,\n                          summary: parsedSource.page_content,\n                          icon: parsedSource.category,\n                          updated_at: parsedSource.updated_at,\n                        },\n                      })\n                    )\n                  }\n                }\n              } catch (e) {\n                console.log('error', source, event.data)\n                console.error(e)\n              }\n            } else if (event.data === STREAMING_EVENTS.DONE) {\n              const sources = parseSources(message)\n              dispatch(\n                actions.setMessageSource({\n                  id: conversationId,\n                  sources,\n                })\n              )\n        \n              dispatch(actions.setStatus({ status: AppStatus.Done }))\n            } else {\n              message += event.data\n\n              dispatch(\n                actions.updateMessage({\n                  id: conversationId,\n                  content: message.replace(/SOURCES:(.+)*/, ''),\n                })\n              )\n            }\n          },\n          async onopen(response) {\n\n            if (response.ok) {\n              return\n            } else if (\n              response.status >= 400 &&\n              response.status < 500 &&\n              response.status !== 429\n            ) {\n              throw new FatalError()\n            } else {\n              throw new RetriableError()\n            }\n          },\n          onerror(err) {\n\n            if (err instanceof FatalError || countRetiresError > 3) {\n              dispatch(actions.setStatus({ status: AppStatus.Error }))\n\n              throw err\n            } else {\n              countRetiresError++\n              console.error(err)\n            }\n          },\n        }\n      )\n    }\n  },\n  abortRequest: () => {\n    return function (dispatch, getState) {\n      const messages = getState().conversation\n      const lastMessage = messages[getState().conversation.length - 1]\n\n      abortController?.abort()\n      abortController = null\n\n      if (!lastMessage.content) {\n        dispatch(\n          actions.removeMessage({\n            id: lastMessage.id,\n          })\n        )\n      }\n      dispatch(\n        actions.setStatus({\n          status: messages.length ? AppStatus.Done : AppStatus.Idle,\n        })\n      )\n    }\n  },\n}\n\nconst parseSources = (\n  message: string\n) => {\n  message = message.replaceAll(\"\\\"\", \"\");\n  const match = message.match(/SOURCES:(.+)*/)\n  if (match && match[1]) {\n    return match[1].split(',').map(element => {\n      return element.trim();\n    });\n  }\n  return  []\n\n}\n\nexport const GlobalStateProvider = ({ children }) => {\n  return <Provider store={store}>{children}</Provider>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}